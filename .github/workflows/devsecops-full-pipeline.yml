name: Full DevSecOps Pipeline (Mirror + Trivy + Sonar + OWASP + Notify)


on:
  workflow_dispatch:
  push:
    branches: ["main"]
    paths:
      - "Source-Code/Application-Code/**"
      - "Kubernetes/**"
      - ".github/workflows/devsecops-full-pipeline.yml"
      - "!Kubernetes/deployment.yml"


permissions:
  contents: write
  pull-requests: write
  id-token: write

env:
  SOURCE_IMAGE: mostafagheta/netflix-clone:latest
  APP_DIR: Source-Code/Application-Code

  AWS_REGION: eu-central-1
  AWS_ACCOUNT_ID: "734468801857"
  ECR_REGISTRY: 734468801857.dkr.ecr.eu-central-1.amazonaws.com
  ECR_REPO: nti_project

  S3_BUCKET: netflix-clone-devsecops-artifacts-734468801857
  S3_PREFIX: netflix-clone-devsecops-mirror

jobs:
  mirror_trivy_push_gitops:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.vars.outputs.tag }}
      ecr_image: ${{ steps.tag.outputs.ecr_image }}
      gitops_branch: ${{ steps.gitops.outputs.branch }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set image tag
        id: vars
        shell: bash
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          echo "tag=main-${SHORT_SHA}" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials (IAM User Keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        shell: bash
        run: aws sts get-caller-identity

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Pull source image (Mostafa)
        shell: bash
        run: docker pull "${SOURCE_IMAGE}"

      - name: Tag image for ECR
        id: tag
        shell: bash
        run: |
          ECR_IMAGE="${ECR_REGISTRY}/${ECR_REPO}:${{ steps.vars.outputs.tag }}"
          docker tag "${SOURCE_IMAGE}" "${ECR_IMAGE}"
          echo "ECR_IMAGE=${ECR_IMAGE}" >> "$GITHUB_ENV"
          echo "ecr_image=${ECR_IMAGE}" >> "$GITHUB_OUTPUT"
          echo "Using ECR_IMAGE=${ECR_IMAGE}"

      - name: Trivy scan (vuln + secret)
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8
        with:
          image-ref: "${{ env.ECR_IMAGE }}"
          scanners: "vuln,secret"
          format: "table"
          output: "trivy-image-report.txt"
          exit-code: "0"
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH,MEDIUM"

      - name: Upload Trivy report (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-image-report
          path: trivy-image-report.txt

      - name: Upload Trivy report to S3
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          KEY="${S3_PREFIX}/trivy/${GITHUB_RUN_ID}/${GITHUB_SHA::7}/trivy-image-report.txt"
          aws s3 cp "trivy-image-report.txt" "s3://${S3_BUCKET}/${KEY}"
          echo "✅ Uploaded: s3://${S3_BUCKET}/${KEY}"

      - name: Push image to ECR
        shell: bash
        run: docker push "${ECR_IMAGE}"

      - name: "GitOps: commit manifest change (unique branch)"
        id: gitops
        shell: bash
        run: |
          set -euo pipefail

          FILE="Kubernetes/deployment.yml"
          SHORT_SHA="${GITHUB_SHA::7}"

          TS="$(date +%s%N)"
          BRANCH="gitops/deploy-${GITHUB_REF_NAME}-${SHORT_SHA}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${TS}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git fetch origin --prune

          if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null 2>&1; then
            BRANCH="${BRANCH}-$RANDOM"
          fi

          echo "Using GitOps branch: $BRANCH"
          git checkout -b "$BRANCH"

          test -f "$FILE" || (echo "❌ File not found: $FILE" && exit 1)
          test -n "${ECR_IMAGE:-}" || (echo "❌ ECR_IMAGE is empty" && exit 1)

          perl -0777 -pi -e "s|(^\\s*image:\\s*).*$|\\1$ECR_IMAGE|mg" "$FILE"

          echo "✅ Updated image to: $ECR_IMAGE"
          grep -nE '^\s*image:\s*' "$FILE" | head -n 10 || true

          git add "$FILE"
          if git diff --cached --quiet; then
            echo "No manifest changes. Skipping."
            echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git commit -m "chore(gitops): deploy image ${ECR_IMAGE}"
          git push -u origin "$BRANCH" --force-with-lease

          echo "✅ Pushed branch: $BRANCH"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

  sonarqube_local:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.RUN_LOCAL_SONAR == 'true'
    runs-on: self-hosted
    needs: [mirror_trivy_push_gitops]

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify SonarQube is reachable (local)
        shell: bash
        run: |
          curl -I http://localhost:9000 | head -n 5

      - name: Recognize App path
        shell: bash
        run: |
          echo "APP_DIR=${{ env.APP_DIR }}"
          ls -la "${{ env.APP_DIR }}" | head
          test -d "${{ env.APP_DIR }}/src" && echo "✅ src exists" || (echo "❌ src missing" && exit 1)

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ${{ env.APP_DIR }}/package-lock.json

      - name: Install deps
        working-directory: ${{ env.APP_DIR }}
        shell: bash
        run: npm ci

      - name: Run tests with coverage (Vitest)
        working-directory: ${{ env.APP_DIR }}
        shell: bash
        run: npm run test:coverage

      - name: Verify lcov exists
        shell: bash
        run: |
          test -f "${{ env.APP_DIR }}/coverage/lcov.info" \
            && echo "✅ lcov found" \
            || (echo "❌ lcov missing" && exit 1)

      - name: SonarQube Local Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        env:
          SONAR_HOST_URL: http://localhost:9000
          SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
        with:
          args: >
            -Dsonar.projectKey=${{ github.repository_owner }}_${{ github.event.repository.name }}_local
            -Dsonar.projectName=netflix-clone-local
            -Dsonar.sources=${{ env.APP_DIR }}/src
            -Dsonar.exclusions=**/node_modules/**,**/dist/**,**/build/**,**/coverage/**,**/*.min.js
            -Dsonar.javascript.lcov.reportPaths=${{ env.APP_DIR }}/coverage/lcov.info

  owasp_dependency_check:
    runs-on: ubuntu-latest
    needs: [mirror_trivy_push_gitops]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: OWASP Dependency-Check (Node)
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: "netflix-devsecops"
          path: "${{ env.APP_DIR }}"
          format: "HTML"
          out: "reports"
          args: "--noupdate --disableYarnAudit"

      - name: Upload OWASP report (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: owasp-dependency-check-report
          path: reports

      - name: Configure AWS credentials (IAM User Keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload OWASP report to S3
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          DEST="s3://${S3_BUCKET}/${S3_PREFIX}/owasp/${GITHUB_RUN_ID}/${GITHUB_SHA::7}/"
          aws s3 cp "reports" "${DEST}" --recursive
          echo "✅ Uploaded: ${DEST}"

  argocd_results:
    if: vars.RUN_EKS_SNAPSHOTS == 'true'
    runs-on: self-hosted
    needs: [mirror_trivy_push_gitops]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare output dir
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p argocd-results

      - name: Configure AWS credentials (IAM User Keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.EKS_REGION }}

      - name: Update kubeconfig for EKS (REQUIRED)
        shell: bash
        run: |
          set -euo pipefail
          test -n "${{ vars.EKS_CLUSTER_NAME }}" || (echo "❌ Missing vars.EKS_CLUSTER_NAME" && exit 1)
          test -n "${{ vars.EKS_REGION }}" || (echo "❌ Missing vars.EKS_REGION" && exit 1)

          aws sts get-caller-identity
          aws eks update-kubeconfig --region "${{ vars.EKS_REGION }}" --name "${{ vars.EKS_CLUSTER_NAME }}"
          kubectl config current-context
          kubectl get nodes -o wide

      - name: Collect ArgoCD + K8s snapshots (EKS)
        shell: bash
        env:
          ARGOCD_NAMESPACE: ${{ vars.ARGOCD_NAMESPACE }}
          ARGOCD_APP_NAME: ${{ vars.ARGOCD_APP_NAME }}
          APP_NAMESPACE: ${{ vars.APP_NAMESPACE }}
        run: |
          set -euo pipefail

          ARGOCD_NAMESPACE="${ARGOCD_NAMESPACE:-argocd}"
          ARGOCD_APP_NAME="${ARGOCD_APP_NAME:-netflix}"
          APP_NAMESPACE="${APP_NAMESPACE:-netflix}"

          kubectl -n "$ARGOCD_NAMESPACE" get application "$ARGOCD_APP_NAME" -o json > argocd-results/application.json
          kubectl -n "$ARGOCD_NAMESPACE" get application "$ARGOCD_APP_NAME" -o yaml > argocd-results/application.yaml

          kubectl -n "$APP_NAMESPACE" get all -o wide > argocd-results/k8s-get-all.txt || true
          kubectl -n "$APP_NAMESPACE" get deploy,pod,svc,ingress -o wide > argocd-results/k8s-core.txt || true
          kubectl -n "$APP_NAMESPACE" get events --sort-by=.lastTimestamp > argocd-results/k8s-events.txt || true

          echo "✅ Collected EKS snapshots."

      - name: Upload ArgoCD results (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: argocd-results
          path: argocd-results

      - name: Upload ArgoCD results to S3
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          DEST="s3://${S3_BUCKET}/${S3_PREFIX}/argocd/${GITHUB_RUN_ID}/${GITHUB_SHA::7}/"
          aws s3 cp "argocd-results" "${DEST}" --recursive
          echo "✅ Uploaded: ${DEST}"

  notify_on_failure:
    runs-on: ubuntu-latest
    needs: [mirror_trivy_push_gitops, sonarqube_local, owasp_dependency_check, argocd_results]
    if: failure()

    steps:
      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        shell: bash
        run: |
          if [ -z "${SLACK_WEBHOOK_URL}" ]; then
            echo "SLACK_WEBHOOK_URL not set - skipping"
            exit 0
          fi
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"❌ DevSecOps pipeline failed on ${GITHUB_REPOSITORY} @ ${GITHUB_SHA::7}.\"}" \
            "${SLACK_WEBHOOK_URL}"

      - name: Notify Teams
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
        shell: bash
        run: |
          if [ -z "${TEAMS_WEBHOOK_URL}" ]; then
            echo "TEAMS_WEBHOOK_URL not set - skipping"
            exit 0
          fi
          curl -H "Content-Type: application/json" \
            -d "{\"text\":\"❌ DevSecOps pipeline failed on ${GITHUB_REPOSITORY} @ ${GITHUB_SHA::7}.\"}" \
            "${TEAMS_WEBHOOK_URL}"
